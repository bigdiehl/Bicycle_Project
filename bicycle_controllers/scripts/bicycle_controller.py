#!/usr/bin/env python3

""" 
DESCRIPTION: Bicycle_Controller node

The aim is for the Bicycle_Controller class to be agnostic to the particular
controller implemented. The Controller class is the parent class for the 
particular controller used by Bicycle_Controller.

""" 

import roslib
import rospy
import time
import math
import tf
from tf.transformations import euler_from_quaternion
import roslib
import numpy as np

from sensor_msgs.msg import JointState
from nav_msgs.msg import Path
from std_msgs.msg import Header
from geometry_msgs.msg import PoseStamped
from bicycle_msgs.msg import BicycleCmd, BicycleStates

# Controllers
from lqr_controller import LQR_Controller
from controller import Differentiator


class BicycleController():

    def __init__(self):
        rospy.init_node('bicycle_controller')
        
        # Will self-parameterize from parameter server
        self.controller = LQR_Controller()

        # Publishers
        self.tau_pub = rospy.Publisher('bicycle/torque_cmd', JointState, queue_size=10)
        self.vel_pub = rospy.Publisher('bicycle/vel_cmd', JointState, queue_size=10)
        self.path_pub = rospy.Publisher('bicycle/position', Path, queue_size=10)
        self.states_pub = rospy.Publisher('bicycle/states', BicycleStates, queue_size=10)

        # Subscribers/Listeners
        self.js_sub = rospy.Subscriber("joint_states", JointState, self.ReadJointStates)
        self.tf_listener = tf.TransformListener()

        # Subscribe to bicycle commands generated by seperate entity
        self.command_sub = rospy.Subscriber("bicycle/command", BicycleCmd, self.ReceiveCommand)

        # Parameters
        self.control_rate = rospy.Rate(rospy.get_param("controller/update_rate", 100)) # Hz. Rate at which actuator commands will be sent
        self.sigma = rospy.get_param("controller/sigma", 0.01)
        self.wheel_radius = rospy.get_param("bicycle/wheel_radius", 0.35)
        self.state_update_rate = rospy.get_param("bicycle_plugin/publish_update_rate")
        self.Ts = 1.0 / self.state_update_rate

        # Position of the back wheel point, P
        self.x = 0 
        self.y = 0 
        self.z = 0

        # Angle states
        self.phi = 0        # Roll angle
        self.phidot = 0     # Roll rate
        self.psi = 0        # Heading angle
        self.psidot = 0     # Heading rate
        self.delta = 0      # Steering angle
        self.deltadot = 0   # Steering angle rate

        # Velocities
        self.vb = 0     # Back wheel angular velocity
        self.vf = 0     # Front wheel angular velocity
        self.v = 0      # Bicycle velocity. Derived from back wheel angular velocity

        # Actuator inputs
        self.Td = 0    # Steering torque

        # High level steering commands. Initialize to maintain initial configuration. 
        self.commands = BicycleCmd()
        self.commands.desired_steer_angle = np.radians(rospy.get_param("bicycle/initial_conditions/delta", 0))
        self.commands.desired_speed = rospy.get_param("bicycle/initial_conditions/vel", 0)

        self.inputs = {}

        # Forces the controller to wait until the first set of states are received. 
        self.first_states_received = False

        # Path msg
        self.path = Path()
        self.path.header.frame_id = 'world'
        self.max_path_length = 200
        self.path_publish_rate = 1 #Hz

        self.rate = rospy.Rate(1)

        self.n = 0
        self.state = 'upright'

    def ReceiveCommand(self, msg):
        """ Receives BicycleCmd message """
        # Note - which values will actually be used depends on the particular controller. 
        self.commands = msg
        #print("Received {:f} steer angle".format(msg.desired_steer_angle))

    def ReadJointStates(self, msg):
        """ Receives JointState messages and extracts the steering angle,
        wheel velocities, etc """

        for i in range(len(msg.name)):
            if msg.name[i] == "back_wheel_joint":
                self.vb = msg.velocity[i]
            elif msg.name[i] == "front_wheel_joint":
                self.vf = msg.velocity[i]
            elif msg.name[i] == "steering_joint":
                self.delta = msg.position[i]
                self.deltadot = msg.velocity[i]
        
        self.v = self.vb * self.wheel_radius        

        # Read the world to base_link transform while we're at it. 
        # TODO - handle this exception better
        try:
            (trans,rot) = self.tf_listener.lookupTransform('world', 'back_frame', rospy.Time(0))
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            rospy.logdebug("Not tf available from world to back_Frame")
            return

        [self.x, self.y, self.z] = trans

        # Convert the rot quaternion to roll and heading angles. 
        [self.psi, pitch, self.phi] = euler_from_quaternion(rot, axes='rzyx')

        # TODO - Perhaps there is a way to directly get the rates from Gazebo? Maybe a service call, or
        # something we can add to the plugin. 
        if not self.first_states_received:
            self.phidot = Differentiator(self.sigma, self.phi)
            self.psidot = Differentiator(self.sigma, self.psi)

        
        # Package into self.inputs for use by the controller
        # TODO - should we just store these in dictionary in first place? rather than in local variables 
        # and then packing up there?
        # TODO - can probably be replaced by BicycleStates msg, below
        # NOTE - delta and deltadot are negative to align with whipple model convention
        self.inputs['phi']      = self.phi
        self.inputs['delta']    = -self.delta
        self.inputs['phidot']   = self.phidot.differentiate(self.phi, self.Ts)
        self.inputs['deltadot'] = -self.deltadot

        states = BicycleStates()
        h = Header()
        h.stamp = rospy.Time.now()
        states.header = h
        states.roll           = self.phi
        states.roll_rate      = self.phidot.get_derivative()
        states.heading        = self.psi
        states.heading_rate   = self.psidot.differentiate(self.psi, self.Ts)
        states.steering_angle = self.delta
        states.steering_rate  = self.deltadot
        states.pos_x          = self.x
        states.pox_y          = self.y
        states.speed          = self.v
        self.states_pub.publish(states)

        self.n += 1
        if self.n > 10:
            self.first_states_received = True


    def publish_path(self, event):
        # h = Header()
        # h.stamp = rospy.Time.now()
        pose_st = PoseStamped()
        pose_st.pose.position.x = self.x
        pose_st.pose.position.y = self.y
        #pose_st.pose.orientation.w = 1
        pose_st.header.frame_id = 'map'
        self.path.poses.append(pose_st)

        # Limit path msg size
        self.path.poses = self.path.poses[-self.max_path_length:]
        
        self.path_pub.publish(self.path)

    def kill_control(self):
        """ Zero steering torque and command back wheel to come to stop. """
        h = Header()
        h.stamp = rospy.Time.now()

        torque_cmd = JointState()
        torque_cmd.header = h
        torque_cmd.name = ["steering_joint"]
        torque_cmd.effort = [0.0]

        vel_cmd = JointState()
        vel_cmd.header = h
        vel_cmd.name = ["back_wheel_joint"]
        vel_cmd.velocity = [0.0]

        self.tau_pub.publish(torque_cmd)
        self.vel_pub.publish(vel_cmd)

    def publish_control(self, event):
        if self.first_states_received:
            [torque_cmd, velocity_cmd, position_cmd] = self.controller.control(self.inputs, self.commands)

            # If we have fallen down, kill controller
            if(np.abs(self.phi) > np.radians(70)):
                self.kill_control()

                if self.state == 'down':
                    rospy.loginfo("Crash detected. state is {}. Ceasing controls".format(self.state))
                    self.state = 'down'                    
        
            else:
                if torque_cmd is not None:
                    self.tau_pub.publish(torque_cmd)

                if velocity_cmd is not None:
                    self.vel_pub.publish(velocity_cmd)

                if position_cmd is not None:
                    pass

    def run(self):
        self.reset()

        # TODO - might be a more elegant way to do this. We basically want to have several 
        # different threads publishing at their own rate, and we want to be able to reset
        # the node whenever the gazebo world is reset (as indicated by time moving backwards)
        while not rospy.is_shutdown():
            try:
                self.rate.sleep()
            except rospy.ROSTimeMovedBackwardsException:
                self.reset()
                rospy.logerr("ROS Time Backwards! Just ignore the exception!")


    def reset(self):
        self.first_states_received = False
        self.path = Path()
        self.path.header.frame_id = 'world'

        rospy.Timer(rospy.Duration(1.0 / 100), self.publish_control)
        rospy.Timer(rospy.Duration(1.0 / 1), self.publish_path)


if __name__ == '__main__':

    # TODO - allow this node to take command line arguments 
    # to customize controller
    bc = BicycleController()
    bc.run()
