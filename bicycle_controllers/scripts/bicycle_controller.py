#!/usr/bin/env python3

""" 
DESCRIPTION: Bicycle_Controller node

The aim is for the Bicycle_Controller class to be agnostic to the particular
controller implemented. The Controller class is the parent class for the 
particular controller used by Bicycle_Controller.

""" 

import roslib
import rospy
import time
import math
import tf
from tf.transformations import euler_from_quaternion
import roslib
import numpy as np

from sensor_msgs.msg import JointState
from std_msgs.msg import Header
from geometry_msgs.msg import Twist
from bicycle_msgs.msg import BicycleCmd

# Controllers
from lqr_controller import LQR_Controller
from controller import Differentiator


class BicycleController():

    def __init__(self):
        rospy.init_node('bicycle_controller')
        
        # Will self-parameterize from parameter server
        self.controller = LQR_Controller()

        # Publish actuator commands
        self.tau_pub = rospy.Publisher('bicycle/torque_cmd', JointState, queue_size=10)
        self.vel_pub = rospy.Publisher('bicycle/vel_cmd', JointState, queue_size=10)

        # Subscribe to state/sensor information
        self.js_sub = rospy.Subscriber("joint_states", JointState, self.ReadJointStates)
        self.tf_listener = tf.TransformListener()

        # Subscribe to bicycle commands generated by seperate entity
        self.command_sub = rospy.Subscriber("bicycle/command", BicycleCmd, self.ReceiveCommand)

        # Parameters
        self.control_rate = rospy.Rate(rospy.get_param("controller/update_rate", 100)) # Hz. Rate at which actuator commands will be sent
        self.sigma = rospy.get_param("controller/sigma", 0.01)
        self.wheel_radius = rospy.get_param("bicycle/wheel_radius", 0.35)
        self.Ts = rospy.get_param("bicycle_plugin/publish_update_rate")

        # Position of the back wheel point, P
        self.x = 0 
        self.y = 0 
        self.z = 0

        # Angle states
        self.phi = 0        # Roll angle
        self.phidot = 0     # Roll rate
        self.psi = 0        # Heading angle
        self.psidot = 0     # Heading rate
        self.delta = 0      # Steering angle
        self.deltadot = 0   # Steering angle rate

        # Velocities
        self.vb = 0     # Back wheel angular velocity
        self.vf = 0     # Front wheel angular velocity
        self.v = 0      # Bicycle velocity. Derived from back wheel angular velocity

        # Actuator inputs
        self.Td = 0    # Steering torque

        # High level steering commands
        self.commands = BicycleCmd()

        self.inputs = {}

        # Forces the controller to wait until the first set of states are received. 
        self.first_states_received = False

    def ReceiveCommand(self, msg):
        """ Receives BicycleCmd message """
        # Note - which values will actually be used depends on the particular controller. 
        self.commands = msg

    def ReadJointStates(self, msg):
        """ Receives JointState messages and extracts the steering angle and
        wheel velocities. """

        for i in range(len(msg.name)):
            if msg.name[i] == "back_wheel_joint":
                self.vb = msg.velocity[i]
            elif msg.name[i] == "front_wheel_joint":
                self.vf = msg.velocity[i]
            elif msg.name[i] == "steering_joint":
                self.delta = msg.position[i]
                self.deltadot = msg.velocity[i]
        
        self.v = self.vb * self.wheel_radius        

        # Read the world to base_link transform while we're at it. 
        # TODO - handle this exception better
        try:
            (trans,rot) = self.tf_listener.lookupTransform('world', 'back_frame', rospy.Time(0))
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            rospy.logdebug("Not tf available from world to back_Frame")
            return

        [self.x, self.y, self.z] = trans

        # Convert the rot quaternion to roll and heading angles. 
        [self.phi, pitch, self.psi] = euler_from_quaternion(rot, axes='rzyx')

        # TODO - Perhaps there is a way to directly get the rates from Gazebo? Maybe a service call, or
        # something we can add to the plugin. 
        if not self.first_states_received:
            self.phidot = Differentiator(self.sigma, self.phi)
            self.psidot = Differentiator(self.sigma, self.psi)

        
        # Package into self.inputs for use by the controller
        # TODO - should we just store these in dictionary in first place? rather than in local variables 
        # and then packing up there?
        self.inputs['phi']      = self.phidot.differentiate(self.phi, self.Ts)
        self.inputs['delta']    = self.delta
        self.inputs['phidot']   = self.phidot.differentiate(self.phi, self.Ts)
        self.inputs['deltadot'] = self.deltadot

        self.first_states_received = True

    def run(self):

        while not rospy.is_shutdown():
            try:
                if self.first_states_received:
                    [torque_cmd, velocity_cmd, position_cmd] = self.controller.control(self.inputs, self.commands)
                    
                    if torque_cmd is not None:
                        self.tau_pub.publish(torque_cmd)

                    if velocity_cmd is not None:
                        self.vel_pub.publish(velocity_cmd)

                    if position_cmd is not None:
                        pass

                self.control_rate.sleep()
            except rospy.ROSTimeMovedBackwardsException:
                self.reset()
                rospy.logerr("ROS Time Backwards! Just ignore the exception!")


    def reset(self):
        self.first_states_received = False


if __name__ == '__main__':

    # TODO - allow this node to take command line arguments 
    # to customize controller
    bc = BicycleController()
    bc.run()
